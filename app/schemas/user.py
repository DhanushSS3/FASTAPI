# app/schemas/user.py

import datetime
from typing import Optional
from pydantic import BaseModel, Field, EmailStr # Import EmailStr for email validation
from decimal import Decimal # Import Decimal for financial fields

# Schema for data received when creating a user (Request Body)
class UserCreate(BaseModel):
    """
    Pydantic model for user registration request data.
    Includes fields required for creating a new user account.
    """
    name: str = Field(..., description="Full name of the user.")
    email: EmailStr = Field(..., description="User's email address (must be unique).") # Use EmailStr for validation
    phone_number: str = Field(..., max_length=20, description="User's phone number (must be unique).")
    password: str = Field(..., min_length=8, description="User's password (will be hashed).") # Add min_length for password strength

    # Required fields as per your list
    city: str = Field(..., description="City of the user.")
    state: str = Field(..., description="State of the user.")
    pincode: int = Field(..., description="Pincode of the user's location.") # Assuming pincode is an integer

    # Optional fields that might be provided during registration or set later
    user_type: Optional[str] = Field(None, max_length=100, description="Type of user (e.g., 'trader', 'investor').")
    security_question: Optional[str] = Field(None, max_length=255, description="Security question for recovery.")
    fund_manager: Optional[str] = Field(None, max_length=255, description="Name of the assigned fund manager.")
    is_self_trading: Optional[int] = Field(1, description="Flag indicating if the user is self-trading (0 or 1). Defaults to 1.")
    group_name: Optional[str] = Field(None, max_length=255, description="Name of the trading group the user belongs to.")

    # Note: Financial fields (wallet_balance, leverage, margin, etc.)
    # and unique identifiers (account_number, reffered_code) are typically
    # generated by the backend after registration, so they are NOT included
    # in the UserCreate schema.

# Schema for data returned after creating/fetching a user (Response Body)
class UserResponse(BaseModel):
    """
    Pydantic model for user response data.
    Excludes sensitive information like the hashed password.
    Includes fields typically returned after fetching user details.
    """
    id: int = Field(..., description="Unique identifier of the user.")
    name: str = Field(..., description="Full name of the user.")
    email: EmailStr = Field(..., description="User's email address.")
    phone_number: str = Field(..., description="User's phone number.")
    user_type: Optional[str] = Field(None, description="Type of user.")

    # Financial Fields (often included in user profile response)
    wallet_balance: Decimal = Field(..., max_digits=18, decimal_places=8, description="Current wallet balance.")
    leverage: Decimal = Field(..., max_digits=10, decimal_places=2, description="User's leverage setting.")
    margin: Decimal = Field(..., max_digits=18, decimal_places=8, description="User's current margin.")

    account_number: Optional[str] = Field(None, description="Unique platform account number.")
    group_name: Optional[str] = Field(None, description="Name of the trading group.")
    status: int = Field(..., description="User account status (0 or 1).") # Assuming 0/1 integer status
    isActive: int = Field(..., description="User active status (0 or 1).") # Assuming 0/1 integer status

    security_question: Optional[str] = Field(None, description="User's security question.")
    city: str = Field(..., description="City of the user.")
    state: str = Field(..., description="State of the user.")
    pincode: Optional[int] = Field(None, description="Pincode of the user's location.") # Pincode might be optional in response if not always set

    fund_manager: Optional[str] = Field(None, description="Name of the assigned fund manager.")
    is_self_trading: int = Field(..., description="Flag indicating if the user is self-trading.")

    # Proof fields (might be included depending on response context, but usually not the images themselves)
    id_proof: Optional[str] = Field(None, description="Path or identifier for ID proof.")
    address_proof: Optional[str] = Field(None, description="Path or identifier for address proof.")

    bank_ifsc_code: Optional[str] = Field(None, description="Bank IFSC code.")
    bank_holder_name: Optional[str] = Field(None, description="Bank account holder name.")
    bank_branch_name: Optional[str] = Field(None, description="Bank branch name.")
    bank_account_number: Optional[str] = Field(None, description="Bank account number.")

    reffered_code: Optional[str] = Field(None, description="User's unique referral code.")
    referred_by_id: Optional[int] = Field(None, description="ID of the user who referred this user.")

    created_at: datetime.datetime = Field(..., description="Timestamp when the user was created.")
    updated_at: datetime.datetime = Field(..., description="Timestamp when the user was last updated.")

    # Configuration for Pydantic to work with SQLAlchemy models
    class Config:
        # Use from_attributes = True for Pydantic V2+
        # Use orm_mode = True for Pydantic V1
        # Check your Pydantic version and use the appropriate setting
        from_attributes = True # Recommended for Pydantic V2+
        # orm_mode = True # Use this for Pydantic V1


# Schema for sending OTP request (reused for password reset request)
class SendOTPRequest(BaseModel):
    """
    Pydantic model for the request body to send an OTP (for verification or password reset).
    """
    email: EmailStr = Field(..., description="Email address to send the OTP to.")

# Schema for verifying OTP request (reused for password reset verification)
class VerifyOTPRequest(BaseModel):
    """
    Pydantic model for the request body to verify an OTP (for verification or password reset).
    """
    email: EmailStr = Field(..., description="Email address associated with the OTP.")
    otp_code: str = Field(..., description="The OTP code received by the user.")

# Schema for password reset request (send OTP)
class RequestPasswordReset(BaseModel):
    """
    Pydantic model for requesting a password reset (sends OTP).
    """
    email: EmailStr = Field(..., description="Email address to send the password reset OTP to.")

# Schema for confirming password reset (verify OTP and set new password)
class ResetPasswordConfirm(BaseModel):
    """
    Pydantic model for confirming password reset and setting a new password.
    """
    email: EmailStr = Field(..., description="Email address associated with the OTP.")
    otp_code: str = Field(..., description="The OTP code received by the user.")
    new_password: str = Field(..., min_length=8, description="The new password for the user account.")

# Schema for OTP/Password Reset response (e.g., success message)
class StatusResponse(BaseModel):
    """
    Generic Pydantic model for simple status responses.
    """
    message: str = Field(..., description="Response message.")
    # You might include other fields here, e.g., a token upon successful verification
    # access_token: Optional[str] = None
    # token_type: Optional[str] = "bearer"
